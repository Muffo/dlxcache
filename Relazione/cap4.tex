\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Progetto del Web Service}
\begin{flushright}\begin{small}\textit{"Any fool can write code that a computer can understand.\\
Good programmers write code that humans can understand."}\\
- Martin Fowler -\\
\end{small}\end{flushright}


\section{Web Service UniversiBO}

\subsection{Interfaccia del servizio}

In una prima fase il design è stato guidato dai requisiti proposti, concentrandosi sulle necessità del cliente del servizio e rendendolo il più generale ed astratto possibile.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/60-servizio-use-case.png}
 \caption{Use case finali del cliente del servizio}
 \label{fig:servizio-use-case}
\end{figure}

L'interfaccia è stata quindi ottenuta come progressivo raffinamento dei casi d'uso previsti dal cliente.\\
A partire dalla prima bozza si è proceduto alle prime implementazioni e in seguito ai problemi incontrati e dai feedback ricevuti dai test, l'interfaccia è stata adattata e semplificata il più possibile seguendo un ciclo iterativo.\\
In questo modo si è potuto alleggerire la complessità dell'operazione di mapping dei dati del database sull'interfaccia, potendo contare sui feedback di ogni iterazione e apportare modifiche all'interfaccia proposta inizialmente in piccoli passi.\\

Saltando i passaggi intermedi, i casi d'uso finali sono rappresentati in figura \ref{fig:servizio-use-case}.\\
Dai casi d'uso si estrapolano le operazioni base che sono schematizzate nella parte inferiore della figura.\\
Mappando direttamente quest'insieme di operazioni base se ne ricava l'interfaccia del servizio descritta dalla seguente Java \texttt{interface}:
\begin{small}\begin{verbatim}
public interface IServiceDidattica
{
  public Facolta[] getFacoltaList()
           throws RemoteException;
  public Facolta getFacolta(String codFac)
           throws RemoteException;
  public Corso[] getCorsoListFacolta(String codFac)
           throws RemoteException;
  public Corso getCorso(String codCorso)
           throws RemoteException;
  public Materia getMateria(String codMateria)
           throws RemoteException;
  public Docente getDocente(String codDoc)
           throws RemoteException;
  public AttivitaDidattica[] getAttivitaDidatticaCorso
           (String codCorso, int annoAccademico)
           throws RemoteException;
  public AttivitaDidattica[] getSdoppiamentiAttivitaDidattica
           (AttivitaDidattica attivitaPadre)
           throws RemoteException;
  public AttivitaDidattica[] getAttivitaDidatticaPadreCorso
           (String codCorso, int annoAccademico)
           throws RemoteException;
}
\end{verbatim}\end{small}

Si noti che l'interfaccia poteva essere descritta tramite WSDL piuttosto che utilizzando il linguaggio Java, la scelta è frutto delle considerazioni riguardanti il ciclo di sviluppo del servizio esposte alla fine del capitolo precedente.\\
Utilizzando Java2WSDL si è poi ottenuta anche la descrizione del servizio tramite WSDL che viene riportato in appendice.\\

I tipi composti \texttt{Facolta}, \texttt{Corso}, \texttt{AttivitaDidattica}, \texttt{Materia} e \texttt{Docente} sono stati costruiti in modo da poter eseguire il mapping sia con le strutture dati descritte nello schema relazionale mostrato a pagina \pageref{relational-schema} che con quelle del Database di Ateneo.\\


\subsection{Implementazione server e client in Java}

Per la gestione dei log, tutte le classi contenenti aspetti critici sono state implementate sfruttando Log4J. Questo aspetto si è rivelato molto utile nella fase di debugging e nella correzione dei molti problemi che si sono incontrati soprattutto nella parte riguardante Web Service Security.\\ 

Tutto lo sviluppo è avvenuto utilizzando JUnit come strumento per automatizzare i test nelle iterazioni del ciclo ``test-sviluppo-refactoring''.\\
Una volta capiti e risolti anche tutti i dettagli riguardanti la piattaforma Axis, descritti nei paragrafi precedenti, l'implementazione risultante è tutto sommato abbastanza semplice in quanto il servizio è costituito dall'esposizione in sola lettura di alcuni dati.\\

I tipi composti sono implementati da semplici classi data container che devono semplicemente fornire i metodi setter/getter per accedere ai dati tipici dei Java Bean.\\

L'implementazione vera e propria del servizio è costituita da una classe \texttt{it.unibo.universibo.didattica.WsDidatticaServerImpl} che si occupa semplicemente di trasfomare le chiamate ai metodi dell'interfaccia in query eseguite su database tramite JDBC.\\

Nel sottopackage \texttt{.test} è presente la suite di test JUnit che verifica il corretto funzionamento dell'implementazione ancor prima che il servizio venga esposto come Web Service.\\

Tramite il web service deployment descriptor è stato scelto l'encoding RPC per il servizio e oltre a indicare la classe che implementa il servizio, devono essere specificati i serializer \texttt{beanMapping} per gestire i tipi composti.
\begin{small}\begin{verbatim}
<deployment xmlns="http://xml.apache.org/axis/wsdd/"
 xmlns:java="http://xml.apache.org/axis/wsdd/providers/java">
 <service name="Didattica" provider="java:RPC">
  <parameter name="className"
    value="it.unibo.universibo.didattica.WsDidatticaServerImpl"/>
  <parameter name="allowedMethods" value="*"/>
  <beanMapping qname="didattica:Facolta"
   xmlns:didattica="urn:didattica.universibo.unibo.it"
   languageSpecificType="java:it.unibo.universibo.didattica.Facolta"/> 
  <beanMapping qname="didattica:Corso"
   xmlns:didattica="urn:didattica.universibo.unibo.it"
   languageSpecificType="java:it.unibo.universibo.didattica.Corso"/>
  <beanMapping qname="didattica:AttivitaDidattica"
   xmlns:didattica="urn:didattica.universibo.unibo.it"
   languageSpecificType="java:it.unibo.universibo.didattica.AttivitaDidattica"/> 
  <beanMapping qname="didattica:Docente"
   xmlns:didattica="urn:didattica.universibo.unibo.it"
   languageSpecificType="java:it.unibo.universibo.didattica.Docente"/> 
  <beanMapping qname="didattica:Materia"
   xmlns:didattica="urn:didattica.universibo.unibo.it"
   languageSpecificType="java:it.unibo.universibo.didattica.Materia"/> 
 </service>
</deployment>
\end{verbatim}\end{small}

Il client stub Java viene generato a partire dal documento WSDL utilizzando WSDL2Java.
Il tool in particolare genera automaticamente un package dal nome  \texttt{it.unibo.universibo.didattica} contenente le classi che descrivono i tipi composti visti in precedenza.\\
In un altro package, con nome relativo all'URI in cui si trova il servizio (nel nostro caso \texttt{localhost.axis.services.Didattica}), vengono generati:
\begin{itemize}
\item \texttt{WsDidatticaServerImpl}: un'interfaccia Java che descrive il servizio che risulterà identica alla nostra interfaccia di partenza, salvo modifiche relative alle eccezioni;
\item \texttt{WsDidatticaServerImplService}: un'interfaccia che descrive una classe che implementa il pattern Factory rispetto all'interfaccia precedente;
\item \texttt{DidatticaSoapBindingStub}: una classe stub che implementa la prima interfaccia \texttt{WsDidatticaServerImpl} e che contiene tutte le invocazioni tramite l'interfaccia JAX-RPC del servizio remoto;
\item \texttt{WsDidatticaServerImplServiceLocator}: una classe che implementa la seconda interfaccia \texttt{WsDidatticaServerImplService} costituendo una Factory concreta attraverso cui istanziare la stub del servizio, dando eventualmente la possibilità di cambiare a run time alcune opzioni.\\
\end{itemize}

Infine lato client è stata riportata la suite di test effettuando solo minime modifiche e sono stati aggiunti, oltre ai test di coerenza, una seconda suite di test di performance.\\

\subsection{Implementazione client PHP}

Per provare il servizio utilizzando un client PHP ci si è appoggiati al già citato pacchetto PEAR::SOAP.\\

Anche tale pacchetto dispone di un tool per generare automaticamenteuna classe stub del Web Service con le seguenti poche righe di codice. La stub presenterà un'interfaccia complementare all'interfaccia Java di partenza.
\begin{small}\begin{verbatim}
<?php
 require_once('SOAP/WSDL.php');
 $wsdl_url = 'http://localhost:8080/axis/services/Didattica?wsdl';
 $wsdl = new SOAP_WSDL($wsdlurl);
 $wsdl->generateProxyCode();
?>
\end{verbatim}\end{small}

La classe generata è stata inserita all'interno dell'architettura di UniversiBO e quindi utilizzando lo strumento di testing PhpUnit già integrato nel sistema sono stati reimplementati in PHP i test di coerenza.\\


\subsection{Esposizione del servizio sul web}
Basandosi sull'interfaccia della stub del servizio è poi stato possibile creare un'interfaccia Web utilizzabile attraverso il browser dagli amministratori che permette recuperare i dati attraverso il Web Service e sincronizzare le informazioni sul database locale di UniversiBO rispettando tutti i vincoli referenziali.\\
L'interfaccia Web del servizio permetterà all'utente di eseguire tutte le operazioni di inserimento dati, aggiornamento e iscrizione degli utenti descritte nei casi d'uso.\\

Il sottosistema Web è stato creato utilizzando il framework di UniversiBO ed inserendo nell'architettura la struttura chiamata \texttt{DataRetriever} descritta nella figura \ref{fig:uml-data-retriever}, che si occuperà di astrarre il sistema di acquisizione dati.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/60b-uml-data-retriever.png}
 \caption{Diagramma delle classi del Data Retiever}
 \label{fig:uml-data-retriever}
\end{figure}

Tramite il \texttt{DataRetriever} si è voluto costruire un wrapper in grado di astrarre la fonte di acquisizione dati. L'interfaccia del \texttt{DataRetriever} in pratica ricalca la stessa prevista dal Web Service.\\
Si è utilizzato il pattern Factory per permettere un passaggio trasparente dall'utilizzo dell'attuale soluzione basata su database esterno, all'utilizzo di un Web Service ed eventualmente altre future soluzioni.\\
Questa forma di flessibilità è stata prevista per permettere ad UniversiBO di acquisire dati nel modo più astratto possibile, per fare in modo che il software risulti eventualmente apettibile in altri contesti e svincolandosi architetturalmente dalla struttura della didattica dell'Ateneo di Bologna.\\

La realizzazione della Graphical User Interface (GUI) Web ha portato a mappare ciascun caso d'uso visto nella parte alta della figura \ref{fig:servizio-use-case} in un'operazione eseguibile tramite una pagina web e quindi in un'estensione di un \texttt{UniversiboCommand} già descritto nel capitolo di introduzione al progetto UniversiBO.\\
I vari comandi si occuperanno di prelevare i dati aggiornati, risolvere le problematiche di sincronizzazione aggiungendo le nuove informazioni richieste e segnalare eventuali conflitti. Il risultato è un'interfaccia Web semplice ed intuitiva che con pochi click permette di gestire in tempo reale problematiche di elevata complessità.\\
 
In figura \ref{fig:web-interface-universibo} viene mostrato un esempio dell'interfaccia Web realizzata.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/60c-web-interface-universibo.png}
 \caption{Interfaccia Web del servizio}
 \label{fig:web-interface-universibo}
\end{figure}


\section{Web Service programmazione didattica di Ateneo}

\subsection{Interfaccia del servizio}

In una seconda fase si è deciso di creare un servizio in grado di cogliere tutta la complessità della nuova struttura della programmazione didattica dell'Ateneo di Bologna.\\
Il nuovo servizio risulterà quindi meno generale, ma più generico nel senso di permettere una copertura di un più ampio spazio dei problemi.\\

Il compito è stato di partire dal design del'architettura del servizio descritto in figura \ref{fig:servizio-classi-interfaccia2} ed estrarne un'interfaccia per accedere in lettura a tutte le sue parti da esporre come servizi web.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/61-servizio-classi-interfaccia2.png}
 \caption{Diagramma delle classi della nuova programmazione didattica di Ateneo}
 \label{fig:servizio-classi-interfaccia2}
\end{figure}

In particolare la struttura proposta mette in evidenza le scomposizioni di \texttt{AttivitaFormativa} in un albero i cui nodi sono costituiti da \texttt{ComponenteAttivitaFormativa}. Ogni nodo dell'albero sarà associato ad un tipo di scomposizione descritto dalla classe \texttt{TipoComponente}. Le foglie di questo albero costituiranno i componenti elementari che possono essere raggruppati in una \texttt{AttivitaReale}: essa rappresenta la singola attivita didattica concreta (equivalente ad una \texttt{PrgAttivitaDidattica} non sdoppiata della vecchia struttura).\\
Per generalizzare il legame tra ogni \texttt{AttivitaReale} ed il personale incaricato a svolgerla, l'associazione è stata modellata tramite la classe intermedia \texttt{Copertura}.\\

Per riuscire ad accedere a tutte le parti della struttura si è deciso di esporre sul Web Service ciascuna associazione secondo ogni possibile verso di navigazione.\\
Si è supposto che il cliente del servizio possa non essere a conoscenza di come siano rappresentati gli identificativi o le chiavi di accesso ad ogni singole entità, quindi l'accesso avviene attraverso elenchi iniziali di alcuni tipi di dato (es: l'elenco dei \texttt{CdS} o l'elenco delle \texttt{Persone}) e successivamente la navigazione avviene in modo trasparente da un oggetto all'altro.\\

Vista la sovrapposizione dei nomi e la non possibilità di sfruttare l'overloading di metodi in un Web Service si è deciso di adottare la convenzione ``\texttt{getTipoRisultato\_TipoRisorsaChiamante}'' nel definire i nomi delle operazioni del servizio.\\
L'interfaccia ottenuta descritta tramite il linguaggio Java è la seguente:

\begin{small}\begin{verbatim}
public interface IService{
 public CdS[] getCdSList() throws RemoteException;
 public Persona[] getPersonaList() throws RemoteException;
 public PianoDidattico getPianoDidattico_CdS (CdS corso, 
   int AnnoAccademico) throws RemoteException;
 public CdS getCds_PianoDidattico (PianoDidattico pianoDidattico) 
   throws RemoteException;
 public AttivitaFormativa[] getAttivitaFormativa_PianoDidattico
   (PianoDidattico piano) throws RemoteException;
 public PianoDidattico getPianoDidattico_AttivitaFormativa
   (AttivitaFormativa attivitaFormativa) throws RemoteException;
 public ComponenteAttivitaFormativa
   getRootComponenteAttivitaFormativa_AttivitaFormativa 
   (AttivitaFormativa attivitaFormativa) throws RemoteException;
 public AttivitaFormativa 
   getAttivitaFormativa_ComponenteAttivitaFormativa 
   (ComponenteAttivitaFormativa componenteAF) throws RemoteException;
 public ComponenteAttivitaFormativa[] 
   getLeafsComponenteAttivitaFormativa_AttivitaFormativa 
   (AttivitaFormativa attivitaFormativa) throws RemoteException;
 public ComponenteAttivitaFormativa 
   getParentComponenteAttivitaFormativa_ComponenteAttivitaFormativa 
   (ComponenteAttivitaFormativa componenteAF) throws RemoteException;
 public ComponenteAttivitaFormativa[]  
   getChildrenComponenteAttivitaFormativa_ComponenteAttivitaFormativa
   (ComponenteAttivitaFormativa componenteAF) throws RemoteException;
 public TipoComponente 
   getTipoComponente_ComponenteAttivitaFormativa 
   (ComponenteAttivitaFormativa componenteAF) throws RemoteException;
 public AttivitaReale getAttivitaReale_ComponenteAttivitaFormativa 
   (ComponenteAttivitaFormativa componenteAF) throws RemoteException;
 public ComponenteAttivitaFormativa[] 
   getComponenteAttivitaFormativa_AttivitaReale 
   (AttivitaReale attivitaReale) throws RemoteException;
 public ComponenteAttivitaFormativa 
   getComponenteAttivitaFormativaMaster_AttivitaReale (AttivitaReale 
   attivitaReale) throws RemoteException;
 public Copertura[] getCopertura_AttivitaReale 
   (AttivitaReale attivitaReale) throws RemoteException;
 public AttivitaReale getAttivitaReale_Copertura
   (Copertura copertura) throws RemoteException;
 public Copertura[] getCopertura_Persona (Persona persona)
   throws RemoteException;
 public Persona getPersona_Copertura (Copertura copertura)
   throws RemoteException;
}
\end{verbatim}\end{small}


\subsection{Implementazione server e client in Java}

Per implementare la struttura lato server, non conoscendo approfonditamente tutte le strutture dati, ci si è limitati ad aggiungere alle classi delle proprietà di esempio per verificarne il corretto funzionamento. Inoltre, non disponendo di una base dati concreta da cui attingere, si è provveduto ad implementare un mock-object in grado di fornire un insieme base di entità di esempio su cui eseguire i test.\\ 

L'esposizione del servizio relativo a questa seconda interfaccia ripercorre gli stessi passi già descritti per il primo progetto; si eviterà pertanto di ripetere le stesse informazioni che portano all'implementazione della skeleton, alla definizione dei descrittori e alla generazione della stub sul client. Anche in questo caso tutte le fasi sono state sviluppate aiutandosi con delle suite di test automatici.\\

\subsection{Esposizione del servizio sul web}

Per poter realizzare una GUI del servizio accessibile tramite il web, in questo caso per puro scopo didattico, si è deciso di implementarla utilizzando la tecnologia Java Server Pages (JSP).\\

L'interfaccia è costituita da una serie di pagine JSP, ognuna delle quali in grado di visualizzare le informazioni relative ad un oggetto di tipo appartenente ad una delle classi descritte precedentemente e i link a tutti gli oggetti associati a quest'ultimo.\\
Per poter eseguire la navigazione tra una pagina e l'altra, senza utilizzare come riferimento gli identificativi degli oggetti nel momento in cui viene invocato il Web Service è stato utilizzato il meccanismo delle sessioni per salvare lo stato di questi oggetti.\\

Il risultato finale ottenuto è un sito Web che permette di navigare tra le strutture dati della programmazione didattica semplicemente passando da una pagina all'altra.\\
In figura \ref{fig:web-interface-did-unibo} viene mostrato un esempio dell'interfaccia Web realizzata.\\


\begin{figure}[!ht]
 \centering
 \includegraphics{img/61b-web-interface-did-unibo.png}
 \caption{Interfaccia Web del servizio}
 \label{fig:web-interface-did-unibo}
\end{figure}

\section{Implementazione dei modelli di sicurezza}

A questo punto per entrambi i servizi sono stati implementati e testati i due modelli di sicurezza intravisti nel primo capitolo.\\
I prossimi esempi mostrati fanno riferimento al servizio UniversiBO ma sono necessarie solo minime modifiche ai nomi dei package e dei namespace per utilizzarli anche nel secondo caso.\\

In entrambi i casi si rende necessaria la conoscenza nell'utilizzo dei certificati in formato X509 o PKCS\#7, del \texttt{keytool} Java per la loro gestione e l'utilizzo in Java dei \texttt{Key Store}, \texttt{Trust Store}, \texttt{Trust Manager} e argomenti correlati alle interfacce Java Authentication and Authorization Service (JAAS) e Java Cryptography Architecture (JCA) che già sono stati intravisti negli esempi relativi a WSS4J.\\
 
Tali problematiche non verranno affrontate in queste pagine, ma sono descritte in maniera approfondita nelle documentazioni dei rispettivi pacchetti. Una visione complessiva di queste tematiche è trattata in maniera semplice e concreta nel libro J2EE Security di Pankaj Kumar\cite{bookJ2EESec}. La descrizione che segue nei prossimi paragrafi, per motivi di spazio non può essere né esaustiva, né vuole sostituire i manuali e la documentazione esistente, ma solo dare qualche indicazione utile per capire i passi da svolgere.\\

Per eseguire i test, sono stati creati dei piccoli script per gestire una Certification Authority, la cui firma che è stata impostata come affidabile in tutti i nostri Trust Store. Per gestire la Certification Authority e la trasformazione dei certificati nei vari formati, sono stati modificati e creati degli apposti script che sfruttano il \texttt{keytool} incluso nell'SDK Java ed OpenSSL (www.openssl.org)\\

\subsection{Fruizione attraverso HTTPS}

Il primo modello prevede l'utilizzo del protocollo HTTP/SSL con verifica del certificato del server e HTTP Basic Authentication per autorizzare il client.\\

Tutti i servlet engine J2EE compatibili devono supportare il protocollo HTTPS. Utilizzandolo è possibile verificare facilmente l'identità del server.\\
Il primo passo è attivare il protocollo HTTPS nel nostro servlet engine (Tomcat) ed installare la nostra chiave privata e il certificato per far risalire la catena di responsabilità fino alla nostra Certification Authority.\\ 

\subsubsection{HTTPS con verifica del server}

La verifica del server avviene aggiungendo nel file di configurazione del servlet engine \texttt{server.xml} un elemento simile al seguente.
\begin{small}\begin{verbatim}
<Connector port="8443" [...]  
  scheme="https" secure="true" clientAuth="false" sslProtocol="TLS"
  keystoreFile="conf/keystore_file_name"
  keystorePass="password_changed"  />
\end{verbatim}\end{small}
L'attributo \texttt{keystoreFile} indica un keystore contenente almeno una chiave privata associata all'alias \texttt{tomcat} mentre l'altro attributo \texttt{keystorePass} indica la password utilizzata per accedere sia al keystore che alla chiave. Le due password possono essere anche differenziate con altri attributi di configurazione.\\
\'E importante che la chiave e di conseguenza il certificato contengano nella proprietà Common Name (CN) il nome dell'host che ospita il servizio, altrimenti non tutti i client potrebbero accettare il certificato.\\

Dal lato client, per attivare HTTPS, è necessario modificare l'endpoint nella stub del servizio con il nuovo protocollo e porta.
\begin{small}\begin{verbatim}
WsDidatticaServerImplServiceLocator locator = 
      new WsDidatticaServerImplServiceLocator();
locator.setDidatticaEndpointAddress(
      "https://localhost:8443/axis/services/Didattica");
\end{verbatim}\end{small}

Per eseguire la verifica del certificato sul client Java è necessario aggiungere sul client le proprietà relative al trustStore ed avere installato in quest'ultimo il certificato della Certification Authority:
\begin{small}\begin{verbatim}
System.setProperty("javax.net.ssl.trustStore","client_cacerts_file");
System.setProperty("javax.net.ssl.trustStorePassword","password");
\end{verbatim}\end{small}
Aggiungendo altre proprietà e attributi alla configurazione di Tomcat è naturalmente possibile eseguire in maniera analoga anche la verifica del client.\\


Anche sul client PHP è possibile utilizzare HTTPS con la verifica del certificato, semplicemente modificando l'endpoint al momento della creazione della stub del servizio.\\
Il client SOAP di PHP utilizza le librerie CURL quindi il metodo per impostare il tipo di connessione è analogo all'interfaccia usata da queste librerie.
\begin{small}\begin{verbatim}
<?php
 $service_stub = 
  new WebService_WsDidatticaServerImplService_Didattica
                  ("https://localhost:8443/axis/services/Didattica");

 // verifica certificato
 $service_stub->setOpt('curl',CURLOPT_SSL_VERIFYPEER,1);
 $service_stub->setOpt('curl',CURLOPT_CAINFO,"file_certX509_fidato");
?>
\end{verbatim}\end{small}



\subsubsection{HTTP Basic Authentication}

La HTTP Basic Authentication prevede l'invio all'interno degli header HTTP di informazioni riguardanti lo username dell'utente e un hash non crittograficamente sicuro della password. \\

Per abilitare il controllo di autenticazione sul server è possibile sia modificare la configurazione del servlet engine o, come nel nostro caso, utilizzare degli handler Axis che permettono una maggiore flessibilità.\\
Il deployment descriptor del servizio dovrà essere modificato aggiungendo i seguenti handler:
\begin{small}\begin{verbatim}
<requestFlow name="authorizationFlow">
 <handler 
  type="java:org.apache.axis.handlers.SimpleAuthenticationHandler"/>
 <handler
  type="java:org.apache.axis.handlers.SimpleAuthorizationHandler"/>
</requestFlow>
<parameter name="allowedRoles" value="my_role"/>
\end{verbatim}\end{small}
Il primo handler si occupa di trasformare l'header di autenticazione in proprietà del \texttt{MessageContext} ed il secondo di eseguire l'autorizzazione dando l'accesso solo agli utenti appartenenti al ruolo indicato. Essi possono essere estratti dal database degli utenti del servlet engine (conf/tomcat-users.xml nel caso di Tomcat).\\
Nel caso si volesse effettuare l'autorizzazione su altre risorse come per esempio database esterni o server LDAP è necessario modificare solo il secondo handler.\\


Nel client Java è necessaria la modifica della stub, aggiungendo prima dell'invocazione del servizio, la chiamata ai metodi JAX-RPC per impostare username e password.
\begin{small}\begin{verbatim}
 call.setProperty(Call.USERNAME_PROPERTY, "my_username");
 call.setProperty(Call.PASSWORD_PROPERTY, "my_password");
\end{verbatim}\end{small}
Il componente di Trasporto HTTP di Axis inserirà poi queste informazioni nell'header HTTP.\\


Nel client PHP basta invocare altri due metodi sulla stub del servizio per impostare le opzioni CURL per la Basic Authentication
\begin{small}\begin{verbatim}
<?php
 $service_stub->setOpt('curl',CURLOPT_HTTPAUTH,CURLAUTH_BASIC );
 $service_stub->setOpt('curl',CURLOPT_USERPWD,
                       "my_username:my_password");
?>
\end{verbatim}\end{small}


% - - - - - -\\
% Web services must often provide their users with the ability to access and
% manipulate state, i.e., data values that persist across, and evolve as a
% result of, Web service interactions. And while Web services successfully
% implement applications that manage state today, we need to define
% conventions for managing state so that applications discover, inspect, and
% interact with stateful resources in standard and interoperable ways. The
% WS-Resource Framework defines these conventions and does so within the
% context of established Web services standards.
% - - - - - -\\ 

\subsection{Fruizione attraverso Web Service Security}

La flessibilità di Web Service Security permette un'ampia gamma di soluzioni di sicurezza in base ai requisiti necessari.\\

Nel nostro caso i requisiti fissi sono dati dalle necessità
\begin{itemize}
\item di autenticare il cliente;
\item di verificare l'integrità dei dati.
\end{itemize}

Per rendere lo scenario più realistico possibile e simulare il caso peggiore si è deciso di ipotizzare, che non sia a disposizione una vera e propria infrastruttura di Certification Authority e gestione dei certificati (che comunque in assenza di un protocollo SAML può diventare onerosa). Quindi tutti i client utilizzano lo stesso certificato e l'autenticazione deve essere effettuata con l'aggiunta di uno username token.\\
Lo scenario sarebbe egualmente valido se si pensa al caso un cui diversi utenti possono accedere ad una macchina client, per cui si vuole sia verificare il certificato del client che autenticare l'utente.\\

In ogni caso prima di procedere bisogna naturalmente generare tutte le chiavi e certificati necessari dalle due parti.\\

Il primo scenario si risolve con la creazione dei seguenti deployment descriptor per il client
\begin{scriptsize}\begin{verbatim}
[...]
<requestFlow>
 <handler type="java:org.apache.ws.axis.security.WSDoAllSender">
  <parameter name="actor" value="server"/>
  <parameter name="action" value="Signature NoSerialization"/>
  <parameter name="user" value="clientKeyAlias"/> 
  <parameter name="signatureUser" value="clientKeyAlias"/>
  <parameter name="passwordCallbackClass"
   value="localhost.axis.services.Didattica.CliCallbackCertKey"/>
  <parameter name="signaturePropFile" value="client.properties" />
  <parameter name="signatureKeyIdentifier" 
   value="DirectReference" />  
 </handler>
 <handler type="java:org.apache.ws.axis.security.WSDoAllSender">
  <parameter name="actor" value="server"/>
  <parameter name="action" value="UsernameToken"/>
  <parameter name="user" value="my_usernane"/> 
  <parameter name="passwordType" value="PasswordDigest" /> 
  <parameter name="passwordCallbackClass"
   value="localhost.axis.services.Didattica.CliPasswordCallback"/>
 </handler>
</requestFlow> 

<responseFlow>
 <handler type="java:org.apache.ws.axis.security.WSDoAllReceiver" >
  <parameter name="passwordCallbackClass"
   value="localhost.axis.services.Didattica.CliCallbackCertKey"/>
  <parameter name="decryptionPropFile" value="wsstest_client.properties" />
  <parameter name="signaturePropFile" value="wsstest_client.properties" />
  <parameter name="encryptionKeyIdentifier" value="X509KeyIdentifier" />
  <parameter name="action" value="Signature" />
 </handler>
</responseFlow>
[...]
\end{verbatim}\end{scriptsize}

ed il seguente per il server:
\begin{scriptsize}\begin{verbatim}
[...]
<requestFlow name="authorizationFlow">
 <handler type="java:org.apache.ws.axis.security.WSDoAllReceiver">
  <parameter name="action" value="Signature UsernameToken"/>
  <parameter name="passwordCallbackClass"
   value="it.unibo.universibo.didattica.ServerCallback"/>
  <parameter name="signaturePropFile" value="server.properties" />
 </handler>
</requestFlow>

<responseFlow>
 <handler type="java:org.apache.ws.axis.security.WSDoAllSender" >
  <parameter name="action" value="Signature" />
  <parameter name="user" value="serverKeyAlias"/>
  <parameter name="signatureUser" value="serverKeyAlias"/>
  <parameter name="passwordCallbackClass"
   value="it.unibo.universibo.didattica.ServerCallbackCertKey"/>
  <parameter name="signaturePropFile" value="server.properties" />
  <parameter name="signatureKeyIdentifier" 
   value="DirectReference" />  
 </handler>
</responseFlow>
[...]
\end{verbatim}\end{scriptsize}

Si noti che nel \texttt{requestFlow} del client sono stati inseriti due handler in sequenza che si occupano di un header con lo stesso \texttt{actor} per poter utilizzare due utenti differenti per la firma e lo \texttt{UsernameToken}.\\
Nella corrispettiva parte ricevente del server abbiamo evitato di mettere invece due handler in sequenza solo per motivi prestazionali, perchè \texttt{WSDoAllReceiver} non è ancora in grado di supportare il \texttt{NoSerialization}. L'unica accortezza di cui tener conto sul server dovrà essere la definizione di un unica Callback in grado di fornire sia la password per il proprio Trust Store che di autenticare lo UsernameToken.\\

In uno scenario alternativo abbiamo inoltre deciso di prevedere altre situazioni in cui le informazioni trasmesse contenessero dati sensibili o di valore.\\
E' stato quindi necessario aggiungere negli handler la cifratura di tutto il body del messaggio SOAP e generare una chiave di tipo RSA per il cifrario.\\
In questo modo approfitteremo per confrontare le prestazioni in uno scenario che offre le stesse garanzie di sicurezza dell'utilizzo di HTTPS.\\

Infine abbiamo provato a cercare liberire e progetti PHP che supportassero Web Service Security, però in questo campo lo sviluppo della piattaforma PHP è ancora molto arretrato, al punto che non esistono ancora librerie per XML Signature e XML Encryption. Lo sviluppo sembra orientato ad aspettare che venga fatto il porting della piattaforma Axis C++ e poi creare un'estensione nativa del linguaggio PHP per interfacciarsi ad essa.\\

\subsection{Test e comparativa}

Come si è già spiegato in precedenza, molti test sono stati eseguiti durante l'implementazione integrandoli nella metodologia di sviluppo adottata. In questo modo si è potuti arrivare al termine dello sviluppo delle interfacce con a disposizione una serie di test di coerenza in grado di verificare il corretto funzionamento in ogni situazione e in ognuno degli scenari di sicurezza proposti.\\ 

Questi test sono stati svolti sia su piattaforma Java utilizzando JUnit, di cui alcuni risultati sono mostrati in figura \ref{fig:test-java}, sia sul client realizzato in PHP utilizzando PHPUnit mostrato in figura \ref{fig:test-php}
\begin{figure}[!ht]
 \centering
 \includegraphics{img/70-test-java.png}
 \caption{Test di coerenza eseguiti con JUnit}
 \label{fig:test-java}
\end{figure}

\begin{figure}[!ht]
 \centering
 \includegraphics{img/71-test-php.png}
 \caption{Test di coerenza eseguiti con PHPUnit}
 \label{fig:test-php}
\end{figure}

Si è deciso di eseguire dei test di performance per confrontare tra loro le soluzioni proposte dai diversi scenari.\\

Riassumendo gli scenari proposti sono:
\begin{itemize}
\item Il servizio in chiaro, utilizzato senza l'utilizzo di nessuna estensione di sicurezza (Plain)\\
\item Il servizio utilizzato tramite il protocollo HTTPS e con HTTP Basic Authentication (HTTPS)\\
\item Il servizio utilizzato tramite lo standard Web Service Security con UnernameToken per identificare l'utente e firma digitale dei messaggi in entrambe le direzioni (WS-Sec1)\\
\item Il servizio utilizzato tramite lo standard Web Service Security con in aggiunta al caso precedente la cifratura completa del Body dei messaggi (WS-Sec2).\\
\end{itemize}

Tutti i benchmark prestazionali sono stati eseguiti su un sistema ripulito di tutti i processi non necessari, utilizzando sempre JUnit in forma testuale come strumento per automatizzare le misure.\\
La macchina di test era un sistema GNU/Linux con kernel 2.6.5 e virtual machine Java 1.4.3\_02.\\
Prima di ogni misura la servlet è stata precaricata in Tomcat in modo da evitare i tempi di ritardo dovuti alla prima esecuzione della servlet.\\
Prima di ogni test che ha coinvolto accessi al database, che nel nostro caso era PostgreSQL 7.4.5, è stato fatto il VACUUM di tutte le tabelle al fine di riottenere le stesse identiche situazioni di partenza.\\ 

A differenza di quanto accade solitamente, tutte le misure sono state effettuate con accuratezza tenendo conto delle giuste basi teoriche di statistica per avere risultati degni di un'interpretazione.\\
Si è supposta la distribuizione delle misure di tipo normale, quindi il campione di misure utilizzato è stato tarato in modo da ottenere un ``intervallo di confidenza al $95\%$ del valor medio campionario'' abbastanza contenuto, per permettere di trarre delle conclusioni dal confronto tra i diversi scenari di misura.\\
Dopo alcune prove si è deciso di accontentarsi di un campione di $n=10$ misure per ogni situazione di test, per cui la T Student assume il valore $t_{\alpha=95\%}=2.286$, che è stato utilizzato per ricavare tutti gli intervalli di confidenza $\varepsilon=(t_{\alpha=95\%})\frac{S}{\sqrt{n}}$, con $S^2$ varianza campionaria.\\ 
Le tabelle con tutti i campioni di misura e tutti i relativi calcoli sono elencati in appendice a pagina \pageref{appendiceTest}.\\


Il primo test valuta il tempo di esecuzione di un servizio semplice, simile ad un piccolo messaggio di echo per avere una prima stima dei tempi di esecuzione.\\
I risultati sono rappresentati in figura \ref{fig:test-simple-service} e permettono di evidenziare fin da subito che mentre i tempi di esecuzione di un servizio con HTPPS sono di pochi punti percentuali superiori al servizio in chiaro, gli scenari con Web Service Security soffrono di un notevole rallentamento, ancora più evidente nel caso sia attivata la cifratura.\\ 

\begin{figure}[!ht]
 \centering
 \includegraphics{img/72-test-simple-service.png}
 \caption{Tempo di esecuzione di un servizio elementare}
 \label{fig:test-simple-service}
\end{figure}

I tempi dei test tengono conto anche dei tempi di setup dell'ambiente di test e dell'ambiente Axis client, quindi per cui per attenuare l'impatto di questi disturbi abbiamo rieseguito lo stesso test con sequenza di 10 e 100 messaggi consecutivi rappresentati in figura \ref{fig:test-sequenza}.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/76-test-sequenza.png}
 \caption{Tempo percentuale di esecuzione di sequenze ripetute di operazioni}
 \label{fig:test-sequenza}
\end{figure}

Come ci si aspettava il peso del caricamento dell'ambiente client è molto elevato, salendo a sequenze di 100 messaggi si tende a mettere in evidenza maggiore le differenze dei tempi di esecuzione per processare un singolo messaggio.\\
Si faccia attenzione che nel grafico i dati sono rappresentati in percentuale rispetto al caso con messaggio in chiaro, e si può osservare che per sequenza di 100 messaggi il costo di processamento dell'header con WS-Security aumenta fino ad oltre il 700\% il costo del servizio.\\
Sempre come ci si aspettava, le distanze che separano le diverse modalità di fruizione rimangono proporzionali in percentuale.\\

Ipotizziamo che il tempo necessario all'esecuzione del test sia dato dalla somma di tre termini: un tempo di setup dell'ambiente di test, un tempo di setup dell'ambiente Axis in base alla configurazione dello scenario ed un tempo di trasmissione per di ogni singolo messaggio.
Disponendo dei dati indicati sopra per 10 e 100 messaggi in sequenza, disponiamo anche di due punti su cui interpolare una retta per misurare il tempo di setup dei tre ambienti.\\

\textcolor{white}{.}\\

\textcolor{white}{.}\\

\pagebreak

I risultati sono riportati nella seguente tabella:\\

\begin{small}\begin{longtable}{|l|c|c|c|c|}
\hline\hline
&Plain&HTTPS&WS-Sec1&WS-Sec2\\
\hline\hline
\textit{t} setup&1.656&1.687&2.810&3.343\\
\hline
\textit{t} msg&0.024&0.071&0.172&0.260\\
\hline\hline
\end{longtable}\end{small}

Si noti che i tempi di setup confermano la correttezza dell'ipotesi permettendo di riottenere i tempi ottenuti nel caso con singolo messaggio.\\
Inoltre si può inutire (anche se si sarebbero dovute eseguire maggiori prove) che il grafico precedente tende asintoticamente al rapporto tra i tempi di processamento dei singoli messaggi $t$ msg riportato in tabella.\\


Si è voluto effettuare un altro test per evidenziare come l'ambiente si comporta sotto altre variazioni, quindi abbiamo misurato i tempi di esecuzione in funzione dell'aumento delle dimensioni del messaggio.\\

\begin{figure}[!ht]
 \centering
 \includegraphics{img/77-test-dimensione.png}
 \caption{Tempo percentuale di esecuzione in base alla dimensione del messaggio}
 \label{fig:test-dimensione}
\end{figure}

Dal grafico di figura \ref{fig:test-dimensione} si può notare come nel caso HTTPS i tempi di esecuzione rimangono costanti in proporzione mentre quando vengono utilizzati XML Signature e XML Encryption, questi algoritmi di cifratura portano ad un notevole degrado delle prestazioni dovendo eseguire le elaborazioni sulla descrizione DOM del documento XML.\\

Volendo invece verificare uno dei punti deboli dell'utilizzo di HTTPS, ossia il traffico generato dall'handshake iniziale abbiamo deciso di effettuare un test inserendo un ritardo di rete.\\
Avendo a disposizione un router amichevole, l'abbiamo istruito in modo da trattenere i pacchetti durante il transito per circa 10 e 100 millisecondi, che sommati in ingresso ed uscita danno 20ms e 200ms. Questi ritardi possono essere valori plausibili di rispettivamente una rete locale e nodi geograficamente distanti su una rete internet.\\   

\begin{figure}[!ht]
 \centering
 \includegraphics{img/78-test-ritardo-rete.png}
 \caption{Tempo percentuale di esecuzione in base al ritardo di rete}
 \label{fig:test-ritardo-rete}
\end{figure}

Abbiamo eseguito i test con il servizio semplice e i dati riportati nel grafico di figura \ref{fig:test-ritardo-rete} ci confermano come l'handshake HTTPS costituisca un rallentamento iniziale delle operazioni all'aumentare del ritardo di rete.\\


Gli ultimi test sono stati eseguiti sulle interfacce che sono state realizzate durante questo progetto, utilizzando un set di operazioni comuni al fine di eseguire concretamente uno dei casi d'uso.
I valori sono complessivi di tutti i tempi di setup, di comunicazione e dei tempi necessari allo svolgimento del servizio che comprendeva diversi accessi a database.\\ 

\begin{figure}[!ht]
 \centering
 \includegraphics{img/74-test-interfaccia1.png}
 \caption{Tempo di esecuzione operazioni comuni sulla prima interfaccia}
 \label{fig:test-interfaccia1}
\end{figure}

Come ci si aspettava i risultati mostrano come la soluzione con HTTPS paghi un rallentamento di pochi punti percentuale, mentre l'impatto sugli scenari con Web Service Security subiscono un rallentamento molto più netto, rispettivamente del 110\% e 210\%.\\ 

